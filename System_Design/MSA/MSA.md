### Monolithic Architecture

: 소프트웨어 프로그램의 전통적인 모델로, 자체 포함 방식이며 다른 애플리케이션과 독립적인 통합된 유닛으로 만들어진다.

- 모든 비즈니스 관련 사항을 함께 결합하는 하나의 코드 베이스를 갖춘 대규모의 단일 컴퓨팅 네트워크
- 애플리케이션을 변경하려면 코드 베이스에 액세스하고 서비스 측 인터페이스의 업데이트된 버전을 구축 및 배포하여 전체 스택을 업데이트해야 한다.
    
    ⇒ 업데이트에 제한이 많고 시간이 오래 걸린다.
    

![image](https://github.com/user-attachments/assets/1b3d3f9e-afde-4cf9-84ce-85463b375165)

> **장점**
>
> 가장 큰 장점은 애플리케이션이 하나의 코드 베이스에 기반을 두어서 단순하기 때문에 개발 속도가 빠르다.

- 실행 파일 또는 디렉토리가 하나여서 배포가 더 쉽다.
- 하나의 코드 베이스로 애플리케이션을 구축하여 개발이 더 쉽다.
- 중앙 집중식 코드 베이스 및 레포지토리에서는 대부분 하나의 API만으로 마이크로서비스에서 여러 API가 수행하는 것과 동일한 기능을 수행할 수 있다.
- 분산된 애플리케이션보다 엔드투엔드 테스트를 더 빠르게 수행할 수 있다.
- 모든 코드가 한 곳에 있으므로 요청을 따라가서 문제를 찾기 더 쉽다.

> **단점**
>
> 규모가 너무 커지고 확장이 어려워지면 더 이상 효과적이지 않다. 하나의 기능을 변경하려고 해도 전체 플랫폼을 컴파일하고 테스트해야 하기 때문에, 오늘날의 **애자일** 접근 방식과 맞지 않는다.

- 대규모 모놀리식 애플리케이션에서는 개발이 더욱 복잡해지고 속도가 느려진다.
- 개별 컴포넌트를 확장할 수 없다.
- 모듈에 오류가 있으면 애플리케이션 전체의 가용성에 영향을 줄 수 있다.
- 프레임워크 또는 언어를 변경하면 애플리케이션 전체에 영향을 미치므로 변경 시 비용과 시간이 많이 소요되는 경우가 많다.
- 약간만 변경하는 경우에도 다시 배포해야 한다.

<br>

---

### MSA(Microservice Architecture)

: 독립적으로 배포 가능한 일련의 서비스를 이용하는 아키텍쳐 방법이며, 특정한 목표를 가진 자체 비즈니스 로직 및 데이터베이스가 있다. 업데이트, 테스트, 배포 및 확장은 각 서비스 내에서 이루어진다.

- 주요 비즈니스, 도메인별 문제를 별도의 독립적인 코드 베이스로 분리한다.
- 복잡성을 줄여주지는 않지만, 작업이 서로 독립적으로 작동하고 전체에 기여하는 더 작은 프로세스로 분리하여 복잡성을 눈으로 볼 수 있고 관리하기 쉽도록 만든다.

![image (1)](https://github.com/user-attachments/assets/a6b88d3e-a640-48cf-8b01-a8b4b4bd09e0)

> **장점**
>
> 마이크로서비스 아키텍처는 독립적으로 실행하는 유닛으로 구성되므로, 다른 서비스에 영향을 주는 일 없이 각 서비스를 개발, 업데이트, 배포 및 확장할 수 있다. 향상된 안정성, 가동 시간 및 성능으로 소프트웨어 업데이트를 더 자주 수행할 수 있다.
>
> CI/CD를 통해 팀이 코드를 더 쉽게 업데이트하고 릴리스 주기를 가속화할 수 있다. 팀에서 코드를 실험해 보고 문제가 발생하면 롤백할 수 있다.

- 배포가 잦은 소규모 팀에서 애자일 작업 방식을 유도한다.
- 마이크로서비스가 부하 용량에 도달하면 해당 서비스의 새 인스턴스를 포함하는 클러스터에 신속하게 배포하여 부담을 완화할 수 있다. 여러 인스턴스에 고객이 분산되어 있는 다중 테넌트 및 상태 비저장이 되었으며 훨씬 더 큰 크기의 인스턴스를 지원할 수 있다.
- 릴리스 주기가 빨라진다.
- 새로운 기능을 실험해 보고 문제가 발생하면 롤백할 수 있다. 코드를 보다 쉽게 업데이트하고 새로운 기능의 시장 출시 시간을 단축할 수 있다. 개별 서비스의 결함과 버그를 쉽게 격리하고 해결할 수 있다.
- 개별적인 유닛이므로 개별 기능을 빠르고 쉽게 독립적으로 배포할 수 있다.
- 팀에서 원하는 도구를 자유롭게 선택할 수 있는 기술의 유연성이 있다.
- 전체 애플리케이션이 중단될 위험없이 특정 서비스에 대한 변경 사항을 배포할 수 있는 높은 안정성을 가진다.

> **단점**
>
> 마이크로서비스는 복잡성을 증가시켜 무분별한 개발 확장 또는 관리되지 않는 급속한 성장으로 이어질 수 있다.
>
> 서로 다른 컴포넌트가 서로 어떻게 관련되어 있는지, 특정 소프트웨어 컴포넌트를 누가 소유하고 있는지, 또는 종속 컴포넌트를 방해하지 않으려면 어떻게 할지 판단하기가 어려울 수 있다. 

- 여러 팀이 더 많은 장소에 더 많은 서비스를 만들기 때문에 모놀리스 아키텍처에 비해 더 복잡해진다. 무분별한 개발 확산이 적절하게 관리되지 않으면 개발 속도가 느려지고 운영 성능이 저하되는 결과가 나타난다.
- 각각의 새 마이크로서비스는 테스트 도구, 배포 플레이북, 호스팅 인프라, 모니터링 도구 등에 대한 자체적인 비용이 발생할 수 있다.
- 팀에서는 업데이트 및 인터페이스를 조정하기 위해 또 다른 커뮤니케이션과 공동 작업이 이루어져야 한다.
- 각 마이크로서비스는 자체적인 로그 집합을 가지고 있어 디버깅이 더 복잡하다. 또한 여러 시스템에서 하나의 비즈니스 프로세스가 실행될 수 있으므로 디버깅이 더욱 복잡해진다.
- 공통 플랫폼이 없어 여러 언어, 로깅 표준 및 모니터링이 사용될 수 있다.
- 더 많은 서비스가 도입됨에 따라 서비스를 실행하는 팀의 수도 늘어난다. 시간이 지나면서 팀에서 어떤 서비스를 활용할 수 있는지, 그리고 지원을 받으려면 누구에게 문의해야 하는지 파악하기가 어려워진다.

<br>

reference - https://www.atlassian.com/ko/microservices/microservices-architecture/microservices-vs-monolith